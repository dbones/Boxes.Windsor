<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Boxes.Integration</name>
    </assembly>
    <members>
        <member name="T:Boxes.Integration.BoxesWrapperExtensions">
            <summary>
            extensions for the boxes wrapper
            </summary>
        </member>
        <member name="M:Boxes.Integration.BoxesWrapperExtensions.TrustManager``2(Boxes.Integration.IBoxesWrapper{``0,``1})">
            <summary>
            the trust manager being used by boxes.
            </summary>
        </member>
        <member name="M:Boxes.Integration.BoxesWrapperExtensions.UseIsolatedSetup``2(Boxes.Integration.IBoxesWrapper{``0,``1},System.String)">
            <summary>
            Setup the package scanner, loader to work with Boxes.Integration, and treats the
            internal dependencies of packages in isolated mode
            </summary>
            <param name="boxes">the boxes wrapper</param>
            <param name="packagesDirectory">location of the packages folder</param>
        </member>
        <member name="M:Boxes.Integration.BoxesWrapperExtensions.UseDefaultSetup``2(Boxes.Integration.IBoxesWrapper{``0,``1},System.String)">
            <summary>
            Setup the package scanner, loader to work with Boxes.Integration, and treats the
            internal dependencies of packages in default mode
            </summary>
            <param name="boxes">the boxes wrapper</param>
            <param name="packagesDirectory">location of the packages folder</param>
        </member>
        <member name="M:Boxes.Integration.BoxesWrapperExtensions.SetupCore``3(Boxes.Integration.IBoxesWrapper{``0,``1},System.String)">
            <summary>
            Setup the package scanner, loader to work with Boxes.Integration
            </summary>
            <param name="boxes">the boxes wrapper</param>
            <param name="packagesDirectory">location of the packages folder</param>
        </member>
        <member name="T:Boxes.Integration.Extensions.ISetupBoxesExtension`1">
            <summary>
            this is the class which will setup a <see cref="T:Boxes.Integration.Extensions.IBoxesExtensionWithSetup"/>
            </summary>
        </member>
        <member name="M:Boxes.Integration.Extensions.ISetupBoxesExtension`1.CanHandle(`0)">
            <summary>
            this allows the setup to refine which extension it will extend, in the event where
            the generic parameter does not provide a concrete class, thus provides limited filtering.
            </summary>
            <param name="extension">the extension to be configured</param>
            <returns>true if this setup will configure the extension</returns>
        </member>
        <member name="M:Boxes.Integration.Extensions.ISetupBoxesExtension`1.Configure(`0)">
            <summary>
            setup the boxes extension
            </summary>
            <param name="extension">the extension to setup</param>
        </member>
        <member name="T:Boxes.Integration.Extensions.IBoxesExtensionWithSetup">
            <summary>
            Extend <see cref="N:Boxes.Integration"/>, its similar to the <see cref="T:Boxes.Integration.Extensions.IBoxesExtension"/> 
            however these types of extension require some form of setup, <see cref="T:Boxes.Integration.Extensions.ISetupBoxesExtension`1"/>.
            </summary>
        </member>
        <member name="T:Boxes.Integration.Extensions.IBoxesExtension">
            <summary>
            Extend <see cref="N:Boxes.Integration"/>,
            this runs before any other package is registered with the applications IoC, to allow room for extensions
            </summary>
        </member>
        <member name="T:Boxes.Integration.Factories.IIocSetup`1">
            <summary>
            A Setup to use with the IoC (this should be injected into the <see cref="T:Boxes.Integration.Factories.IIocFactory`2"/>)
            </summary>
            <typeparam name="TBuilder">the IoC setup</typeparam>
        </member>
        <member name="M:Boxes.Integration.Factories.IIocSetup`1.Configure(`0)">
            <summary>
            configure the main container
            </summary>
            <param name="builder">the main container builder, (this should be before any registrations)</param>
        </member>
        <member name="M:Boxes.Integration.Factories.IIocSetup`1.ConfigureChild(`0)">
            <summary>
            configure a child container
            </summary>
            <param name="builder">the child builder, (this should be before any registrations)</param>
        </member>
        <member name="T:Boxes.Integration.Factories.IocSetup`1">
            <summary>
            does nothing, vanilla setup of the ioc
            </summary>
            <typeparam name="TBuilder"></typeparam>
        </member>
        <member name="T:Boxes.Integration.InternalIoc.IInternalContainer">
            <summary>
            A simple internal container, which will manage the services available in Boxes.
            </summary>
        </member>
        <member name="T:Boxes.Integration.InternalIoc.Registration">
            <summary>
            a registration of a contract with a given service.
            </summary>
        </member>
        <member name="P:Boxes.Integration.InternalIoc.Registration.IsDefault">
            <summary>
            is this set via boxes, or an extension
            </summary>
        </member>
        <member name="P:Boxes.Integration.InternalIoc.Registration.IsAllowedToBeOverridden">
            <summary>
            indicate if the component is allowed to be overridden
            </summary>
        </member>
        <member name="T:Boxes.Integration.InternalContainerExtensions">
            <summary>
            some extensions for the internal container
            </summary>
        </member>
        <member name="T:Boxes.Integration.InternalIoc.InternalInternalContainer">
            <summary>
            this container is a simple internalContainer which handles all contracts as singletons, (very limited functionality)
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.Filters.DefaultTypeRegistrationFilter">
            <summary>
            the default will return all exported types
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.Filters.ITypeRegistrationFilter">
            <summary>
            Filter types which are to be registered with the IoC
            </summary>
        </member>
        <member name="M:Boxes.Integration.Setup.Filters.ITypeRegistrationFilter.FilterTypes(Boxes.Package)">
            <summary>
            filter out the types for a package
            </summary>
            <param name="package">the package to extract the types from</param>
            <returns>a set of types which will be used for IoC registration</returns>
        </member>
        <member name="T:Boxes.Integration.Setup.IInterceptionSelector">
            <summary>
            the selector will indicate what interceptors to apply on a given registration
            </summary>
        </member>
        <member name="M:Boxes.Integration.Setup.IInterceptionSelector.InterceptorsToApply(Boxes.Integration.Setup.Interception.InterceptionContext)">
            <summary>
            find the interceptor types to apply on a registration
            </summary>
            <param name="ctx">contains all the inforamtion required to see which interceptor types will be returned</param>
            <returns>a distinct list of interceptor types</returns>
        </member>
        <member name="T:Boxes.Integration.Setup.Interception.InterceptionContext">
            <summary>
            contains information about an interception context
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.Interception.InterceptionContext.Contracts">
            <summary>
            the contracts which we have registered the service with
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.Interception.InterceptionContext.Service">
            <summary>
            the concrete service which will satisfy the contract
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.Interception.InterceptorMeta">
            <summary>
            contains information on when and where to apply an Aspect
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.Interception.InterceptorMeta.Where">
            <summary>
            when to apply this interceptor
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.Interception.InterceptorMeta.Interceptor">
            <summary>
            the interceptor to apply
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.Interception.IRegisterInterception">
            <summary>
            register an interceptor/aspect for AOP
            </summary>
        </member>
        <member name="M:Boxes.Integration.Setup.Interception.IRegisterInterception.Where(System.Predicate{Boxes.Integration.Setup.Interception.InterceptionContext})">
            <summary>
            apply a filter (pattern) to find which types this registration will apply too
            </summary>
            <param name="where">the pattern to find the types this registration applies too</param>
        </member>
        <member name="M:Boxes.Integration.Setup.Interception.IRegisterInterception.Apply(System.Type[])">
            <summary>
            the interceptors to apply
            </summary>
            <param name="interceptor">interceptors to apply</param>
        </member>
        <member name="M:Boxes.Integration.Setup.Interception.IRegisterInterception.Apply``1">
            <summary>
            the interceptor apply
            </summary>
            <typeparam name="T">the interceptor to apply</typeparam>
        </member>
        <member name="T:Boxes.Integration.Setup.IRegistrationTaskMapper`1">
            <summary>
            this provides a mechanism to create the required boxes tasks for registration
            </summary>
            <typeparam name="TBuilder">the IoC builder</typeparam>
        </member>
        <member name="M:Boxes.Integration.Setup.IRegistrationTaskMapper`1.SetInterceptionSelector(Boxes.Integration.Setup.IInterceptionSelector)">
            <summary>
            set the interceptor selector which can be used with the registration task
            </summary>
            <param name="interceptionSelector">the registration selector</param>
        </member>
        <member name="M:Boxes.Integration.Setup.IRegistrationTaskMapper`1.CreateRegisterTask(Boxes.Integration.Setup.RegistrationMeta)">
            <summary>
            create a boxes registration task from the <see cref="T:Boxes.Integration.Setup.RegistrationMeta"/>
            </summary>
            <param name="registration">the registration to be tasked up</param>
        </member>
        <member name="T:Boxes.Integration.Setup.IDefaultContainerSetup`1">
            <summary>
            default container setup
            </summary>
            <typeparam name="TBuilder">the ioc builder class</typeparam>
        </member>
        <member name="T:Boxes.Integration.Setup.IContainerSetup`1">
            <summary>
            setup how LifeStyles will be managed
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.IContainerSetup">
            <summary>
            the setup for this area of the application
            </summary>
        </member>
        <member name="M:Boxes.Integration.Setup.IContainerSetup.AddInterception(Boxes.Integration.Setup.Interception.IRegisterInterception)">
            <summary>
            add an interceptor/aspect to the container
            </summary>
            <param name="registerInterception">the registration</param>
        </member>
        <member name="M:Boxes.Integration.Setup.IContainerSetup.AddRegistration(Boxes.Integration.Setup.Registrations.IRegister)">
            <summary>
            Register a type (can be as simple as does it implement a Dependency or to apply a filter)
            </summary>
            <param name="registration">The registration with details on how setup the IoC with the types which match the where clause</param>
        </member>
        <member name="M:Boxes.Integration.Setup.IContainerSetup.SetDefaultFilter(Boxes.Integration.Setup.Filters.ITypeRegistrationFilter)">
            <summary>
            override the default package filter (this will be used across all packages)
            </summary>
            <param name="typeTypesFilter">the filter</param>
        </member>
        <member name="M:Boxes.Integration.Setup.IContainerSetup.AddPackgeLevelFilter(Boxes.Integration.Setup.Filters.ITypeRegistrationFilter,System.String[])">
            <summary>
            set a filter for a particular package, some packages may require their own filters
            </summary>
            <param name="typesFilterTypes">the filter</param>
            <param name="packgeName">packages which </param>
        </member>
        <member name="M:Boxes.Integration.Setup.IContainerSetup.GetTypeRegistrationFilter(System.String)">
            <summary>
            get the filter for a given package
            </summary>
            <param name="packageName">name of the package</param>
            <returns>null if there is not filter</returns>
        </member>
        <member name="P:Boxes.Integration.Setup.IContainerSetup.DefaultTypeRegistrationFilter">
            <summary>
            the default filter to find exported classes with
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.IContainerSetup`1.Registrations">
            <summary>
            all the registration to run the types through
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.ContainerSetupBase`1">
            <summary>
            abstract for the <see cref="T:Boxes.Integration.Setup.IContainerSetup`1"/>, inherit this in the IoC project
            </summary>
            <typeparam name="TBuilder">the builder which the IoC will use</typeparam>
        </member>
        <member name="T:Boxes.Integration.Exceptions.ServiceTypeDoesNotMatchInstanceException">
            <summary>
            raise when trying to set the instance of a service inside the internal ioc, when the instance does not match the service
            </summary>
        </member>
        <member name="P:Boxes.Integration.Exceptions.ServiceTypeDoesNotMatchInstanceException.Service">
            <summary>
            service which the instance is supposed to be registered with
            </summary>
        </member>
        <member name="P:Boxes.Integration.Exceptions.ServiceTypeDoesNotMatchInstanceException.Instance">
            <summary>
            the instance being registered
            </summary>
        </member>
        <member name="T:Boxes.Integration.Exceptions.FailedTrustException">
            <summary>
            raise this when the application fails trust
            </summary>
        </member>
        <member name="P:Boxes.Integration.Exceptions.FailedTrustException.Context">
            <summary>
            the context
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.Registrations.LifeStyle">
            <summary>
            The scope to apply to an instace of a type.
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.Registrations.IRegister">
            <summary>
            This class provides a mechanism to setup the registration of types with the underlying IoC.
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.Registrations.IRegister.RegistrationMeta">
            <summary>
            meta information about the registration
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.SetupGenericContainer">
            <summary>
            setup any container container (this will not be able to access any container special-isms)
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.SetupGenericContainer.Register">
            <summary>
            create a new registration pattern
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.SetupGenericContainer.RegisterInterception">
            <summary>
            create a new interception (AOP) pattern
            </summary>
        </member>
        <member name="T:Boxes.Integration.StringExtension">
            <summary>
            couple of string extensions
            </summary>
        </member>
        <member name="M:Boxes.Integration.StringExtension.FormatWith(System.String,System.Object[])">
            <summary>
            format the string, "{0} world".FormatWith("Hello");
            </summary>
            <param name="str"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:Boxes.Integration.Trust.Contexts.BoxesExtensions.AssemblyFromPackageTrustContext">
            <summary>
            check to see if an assembly/module from a package is ok (Boxes Extension)
            </summary>
        </member>
        <member name="T:Boxes.Integration.Trust.Contexts.TrustContext">
            <summary>
            the base trust context 
            note this class is empty allowing for context to be almost anything
            </summary>
            <remarks>
            ensure what you do use as a context it should be sealed
            </remarks>
        </member>
        <member name="P:Boxes.Integration.Trust.Contexts.BoxesExtensions.AssemblyFromPackageTrustContext.Assembly">
            <summary>
            the assembly/module in question
            </summary>
        </member>
        <member name="P:Boxes.Integration.Trust.Contexts.BoxesExtensions.AssemblyFromPackageTrustContext.Package">
            <summary>
            package the assembly resides in
            </summary>
        </member>
        <member name="T:Boxes.Integration.Trust.Contexts.BoxesExtensions.SetupFromPackageTrustContext">
            <summary>
            check to see if a package is allowed to configure a component (Boxes Extension)
            </summary>
        </member>
        <member name="P:Boxes.Integration.Trust.Contexts.BoxesExtensions.SetupFromPackageTrustContext.Contract">
            <summary>
            the contract being setup
            </summary>
        </member>
        <member name="P:Boxes.Integration.Trust.Contexts.BoxesExtensions.SetupFromPackageTrustContext.Setup">
            <summary>
            the class which will setup the contract
            </summary>
        </member>
        <member name="P:Boxes.Integration.Trust.Contexts.BoxesExtensions.SetupFromPackageTrustContext.Package">
            <summary>
            the package where the setup resides
            </summary>
        </member>
        <member name="T:Boxes.Integration.TypeExtensions">
            <summary>
            some type extensions
            </summary>
        </member>
        <member name="M:Boxes.Integration.TypeExtensions.Is``1(System.Type)">
            <summary>
            returns of the current type is equal to the generic
            </summary>
            <typeparam name="TService">compare the type to this</typeparam>
            <param name="type">the type to compare</param>
        </member>
        <member name="M:Boxes.Integration.TypeExtensions.AllInterfaces(System.Type)">
            <summary>
            Get all the interfaces this class implements
            </summary>
            <param name="type">the type of interest</param>
        </member>
        <member name="M:Boxes.Integration.TypeExtensions.FirstInterface(System.Type)">
            <summary>
            The first interface a type implements
            </summary>
            <param name="type">the type of interest</param>
        </member>
        <member name="M:Boxes.Integration.TypeExtensions.SelfAndAllInterfaces(System.Type)">
            <summary>
            Gets all the interfaces this type implements, it also adds the type of interest to the result set
            </summary>
            <param name="type">the type of interest</param>
        </member>
        <member name="T:Boxes.Integration.Setup.Registrations.IRegister`2">
            <summary>
            This class provides a mechanism to setup the registration of types with the underlying IoC.
            </summary>
            <typeparam name="TScope">The signature for the scope/lifestyle</typeparam>
            <typeparam name="TConfiguration">the IoC direct configuration for the current registration</typeparam>
        </member>
        <member name="M:Boxes.Integration.Setup.Registrations.IRegister`2.Where(System.Predicate{System.Type})">
            <summary>
            apply a filter (pattern) to find which types this registration will apply too
            </summary>
            <param name="where">the pattern to find the types this registration applies too</param>
        </member>
        <member name="M:Boxes.Integration.Setup.Registrations.IRegister`2.AssociateWith(Boxes.Integration.Setup.Registrations.Contracts)">
            <summary>
            which contracts to associate the current type with
            </summary>
            <param name="contracts">select the appropriate contracts to register this class with</param>
        </member>
        <member name="M:Boxes.Integration.Setup.Registrations.IRegister`2.AssociateWith(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            which contracts to associate the current type with
            </summary>
            <param name="contracts">provide a list of contracts to associate the current type with</param>
        </member>
        <member name="M:Boxes.Integration.Setup.Registrations.IRegister`2.AssociateWith(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            which contracts to associate the current type with
            </summary>
            <param name="contracts">provide a list of contracts to associate the current type with</param>
        </member>
        <member name="M:Boxes.Integration.Setup.Registrations.IRegister`2.Ctor(System.Func{System.Object})">
            <summary>
            supply a ctor to use, apply this in the Configure Method, as this will allow direct access
            to the actual IoC's registration
            </summary>
            <param name="factoryMethod">the ctor to use</param>
        </member>
        <member name="M:Boxes.Integration.Setup.Registrations.IRegister`2.LifeStyle(`0)">
            <summary>
            the life style of the type (scope and lifestyle are considered to be the same thing at this point)
            </summary>
            <param name="lifeStyle">the life style to use</param>
        </member>
        <member name="M:Boxes.Integration.Setup.Registrations.IRegister`2.Scope(`0)">
            <summary>
            the scope of the type (scope and lifestyle are considered to be the same thing at this point)
            </summary>
            <param name="scope">the scope to use</param>
        </member>
        <member name="M:Boxes.Integration.Setup.Registrations.IRegister`2.Configure(System.Action{Boxes.Integration.Setup.Registrations.RegisterContext{`1}})">
            <summary>
            direct access to the IoC's registration, Recommended for the more advanced setup's
            </summary>
            <param name="cfg">ioc's registration</param>
        </member>
        <member name="T:Boxes.Integration.Setup.Registrations.RegisterBase`2">
            <summary>
            This class provides a mechanism to setup the registration of types with the underlying IoC.
            </summary>
            <remarks>
            note this is abstract, it is inherited by the container implementation, 
            this was to make the API easier to work with 
            IE new Register() VS new Register[Type, WindsorContainer]() 
            the latter is not friendly to do
            </remarks>
        </member>
        <member name="T:Boxes.Integration.Setup.Registrations.RegisterContext`1">
            <summary>
            a register context holds all the information required for someone to have complete control
            over a single types registration.
            </summary>
            <typeparam name="TConfiguration">the underlying IoC registration type</typeparam>
        </member>
        <member name="P:Boxes.Integration.Setup.Registrations.RegisterContext`1.Configuration">
            <summary>
            the configuration of the underlying IoC registration
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.Registrations.RegisterContext`1.Type">
            <summary>
            the type the configuration is for
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.RegistrationContext`1">
            <summary>
            the context for the registration
            </summary>
            <typeparam name="TBuilder">the current builder</typeparam>
        </member>
        <member name="P:Boxes.Integration.Setup.RegistrationContext`1.Type">
            <summary>
            the type to register
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.RegistrationContext`1.Builder">
            <summary>
            the builder to register it with
            </summary>
        </member>
        <member name="T:Boxes.Integration.Exceptions.CreateLoaderException">
            <summary>
            there is no <see cref="T:Boxes.Integration.Factories.ICreateLoader"/> registered for this type
            </summary>
        </member>
        <member name="P:Boxes.Integration.Exceptions.CreateLoaderException.LoaderType">
            <summary>
            the loader which requires a creator
            </summary>
        </member>
        <member name="T:Boxes.Integration.Factories.FuncCreateLoader`1">
            <summary>
            creates a Loader, based on a Func which is passed in via the ctor
            </summary>
            <typeparam name="TLoader"></typeparam>
        </member>
        <member name="T:Boxes.Integration.Factories.ICreateLoader">
            <summary>
            create a loader
            </summary>
        </member>
        <member name="M:Boxes.Integration.Factories.ICreateLoader.Ctor(Boxes.PackageRegistry)">
            <summary>
            creates an instance of a loader
            </summary>
            <param name="packageRegistry">the current <see cref="T:Boxes.PackageRegistry"/></param>
            <returns>the loader instance</returns>
        </member>
        <member name="T:Boxes.Integration.Factories.IDependencyResolverFactory">
            <summary>
            create an instance of a dependency resolver
            </summary>
        </member>
        <member name="M:Boxes.Integration.Factories.IDependencyResolverFactory.CreateResolver(System.Object)">
            <summary>
            create an instance of a dependency resolver
            </summary>
            <param name="container">the container which the dependency resolver will wrap around</param>
            <returns>a dependency resolver</returns>
        </member>
        <member name="T:Boxes.Integration.Factories.IIocFactory`2">
            <summary>
            create instances of containers as required
            </summary>
        </member>
        <member name="M:Boxes.Integration.Factories.IIocFactory`2.CreateBuilder">
            <summary>
            create an instance of the IoC Builder
            </summary>
            <returns>an IoC builder, in most cases this may just be the IoC container</returns>
        </member>
        <member name="M:Boxes.Integration.Factories.IIocFactory`2.CreateBuilder(`1)">
            <summary>
            create an instance of the IoC Builder for a child container
            </summary>
            <param name="parentContainer">the parent IoC container</param>
            <returns>a IoC builder, in most cases this may just be the child IoC container</returns>
        </member>
        <member name="M:Boxes.Integration.Factories.IIocFactory`2.CreateContainer(`0)">
            <summary>
            Creates an instance of the main container
            </summary>
        </member>
        <member name="M:Boxes.Integration.Factories.IIocFactory`2.CreateChildContainer(`1,`0)">
            <summary>
            Creates a child container, off the main container
            </summary>
        </member>
        <member name="T:Boxes.Integration.Factories.LoaderFactory">
            <summary>
            Provides the way to create a <see cref="T:Boxes.Loading.ILoader"/>, you can register custom loaders here too
            </summary>
        </member>
        <member name="M:Boxes.Integration.Factories.LoaderFactory.AddCreateLoader``1(Boxes.Integration.Factories.ICreateLoader)">
            <summary>
            register a way to create a loader
            </summary>
            <typeparam name="TLoader">the loader type</typeparam>
            <param name="createLoader">the way to create it</param>
        </member>
        <member name="M:Boxes.Integration.Factories.LoaderFactory.AddCreateLoader``1(System.Func{Boxes.PackageRegistry,``0})">
            <summary>
            register a way to create a loader, using a Lambda Func
            </summary>
            <typeparam name="TLoader">the loader type</typeparam>
            <param name="ctor">the func which can create the loader</param>
        </member>
        <member name="M:Boxes.Integration.Factories.LoaderFactory.CreateLoader``1(Boxes.PackageRegistry)">
            <summary>
            creates the required loader
            </summary>
            <typeparam name="TLoader">the loader type</typeparam>
            <param name="packageRegistry">the current <see cref="T:Boxes.PackageRegistry"/></param>
            <returns>fully constructed loader</returns>
        </member>
        <member name="T:Boxes.Integration.ObjectExtensions">
            <summary>
            object level extensions
            </summary>
        </member>
        <member name="M:Boxes.Integration.ObjectExtensions.TryDispose(System.Object)">
            <summary>
            this will try to dispose of the current object, it will run the IDosable interface, if it is implemented
            </summary>
            <param name="obj">the object to try to dispose of</param>
        </member>
        <member name="T:Boxes.Integration.Process.TopologicalProcessOrder">
            <summary>
            Process the packages using a simple Topological order
            </summary>
        </member>
        <member name="T:Boxes.Integration.Process.IProcessOrder">
            <summary>
            Set the order to process the packages 
            </summary>
        </member>
        <member name="M:Boxes.Integration.Process.IProcessOrder.Arrange(System.Collections.Generic.IEnumerable{Boxes.Package})">
            <summary>
            arranges the packages ready to be processed
            </summary>
            <param name="packages">the latest, unprocessed packages</param>
            <returns>the packages in order, ready to be processed</returns>
        </member>
        <member name="T:Boxes.Integration.Process.TopologicalSortExtensions">
            <summary>
            helpful extensions
            </summary>
        </member>
        <member name="M:Boxes.Integration.Process.TopologicalSortExtensions.PerformTopologicalSort``1(System.Collections.Generic.IEnumerable{Boxes.Integration.Process.Node{``0}})">
            <summary>
            perform a topological sort
            </summary>
            <typeparam name="T">the type the nodes will represent</typeparam>
            <param name="nodes">the list of nodes to sort</param>
            <returns>sorted by dependency</returns>
        </member>
        <member name="M:Boxes.Integration.Process.TopologicalSortExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            for each
            </summary>
            <typeparam name="T">the type in the collection</typeparam>
            <param name="collection">the collection</param>
            <param name="action">action to perform on each item</param>
        </member>
        <member name="T:Boxes.Integration.BoxesWrapperBase`2">
            <summary>
            this wrapper of boxes.core, this will integrate the features of boxes with an IoC container
            </summary>
            <typeparam name="TBuilder">the type used to build registrations</typeparam>
            <typeparam name="TContainer">the type of the container, this will be used to resolve the instances</typeparam>
            <remarks>
            do not remove the TContainer this is used with the extension methods and with the other classes in the system</remarks>
        </member>
        <member name="T:Boxes.Integration.IBoxesWrapper`2">
            <summary>
            takes Boxes and extends it to provide lifestyle management with Dependency Injection along with the (isolated) module loading
            </summary>
            <remarks>
            the generic type is require to help the extension methods, do not get rid of it
            </remarks>
        </member>
        <member name="M:Boxes.Integration.IBoxesWrapper`2.Setup``1(Boxes.Discovering.IPackageScanner)">
            <summary>
            Setup Boxes with the <see cref="T:Boxes.Loading.ILoader"/> and default <see cref="T:Boxes.Discovering.IPackageScanner"/> 
            </summary>
            <typeparam name="TLoader">the type of the loader to use with boxes</typeparam>
            <param name="defaultPackageScanner">the default scanner to use to find modules with</param>
        </member>
        <member name="M:Boxes.Integration.IBoxesWrapper`2.DiscoverPackages(Boxes.Discovering.IPackageScanner)">
            <summary>
            Discover packages, using a supplied <see cref="T:Boxes.Discovering.IPackageScanner"/>
            </summary>
            <param name="packageScanner">package scanner to discovery packages with</param>
        </member>
        <member name="M:Boxes.Integration.IBoxesWrapper`2.DiscoverPackages">
            <summary>
            Discover packages, using the default <see cref="T:Boxes.Discovering.IPackageScanner"/>
            </summary>
        </member>
        <member name="M:Boxes.Integration.IBoxesWrapper`2.LoadPackages">
            <summary>
            Load packages ready for the application to use
            </summary>
        </member>
        <member name="M:Boxes.Integration.IBoxesWrapper`2.GetService``1">
            <summary>
            get an internal service
            </summary>
            <typeparam name="T">The service to return</typeparam>
            <returns>null if it it does not exist</returns>
        </member>
        <member name="P:Boxes.Integration.IBoxesWrapper`2.PackageRegistry">
            <summary>
            package registry, this will provide the information of what modules have been loaded
            </summary>
        </member>
        <member name="M:Boxes.Integration.BoxesWrapperBase`2.Initialize(Boxes.Integration.InternalIoc.IInternalContainer)">
            <summary>
            setup boxes integration with the IoC implementation (register types with the internal IoC)
            </summary>
        </member>
        <member name="T:Boxes.Integration.ExtensionManifest">
            <summary>
            Manifest information for a package, this also includes any extensions the package includes
            </summary>
        </member>
        <member name="P:Boxes.Integration.ExtensionManifest.Extensions">
            <summary>
            list of all the modules which extend Boxes functionality
            </summary>
        </member>
        <member name="T:Boxes.Integration.ProcessPackageContext">
            <summary>
            the context of a package while it is being processed
            </summary>
        </member>
        <member name="M:Boxes.Integration.ProcessPackageContext.#ctor(Boxes.Package,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            default ctor
            </summary>
            <param name="package">package</param>
            <param name="dependencyTypes">types of interest</param>
        </member>
        <member name="P:Boxes.Integration.ProcessPackageContext.Package">
            <summary>
            the package
            </summary>
        </member>
        <member name="P:Boxes.Integration.ProcessPackageContext.DependencyTypes">
            <summary>
            all the types of interest
            </summary>
        </member>
        <member name="T:Boxes.Integration.Tasks.PipelineExecutorWrapper`1">
            <summary>
            wrappers arround a single pipeline, and offers a simple
            way to update the tasks the pipeline will carry out.
            </summary>
            <typeparam name="T">the type which the tasks in the pipeline are</typeparam>
        </member>
        <member name="M:Boxes.Integration.Tasks.PipelineExecutorWrapper`1.#ctor">
            <summary>
            create wrapper with no tasks
            </summary>
        </member>
        <member name="M:Boxes.Integration.Tasks.PipelineExecutorWrapper`1.#ctor(System.Collections.Generic.IEnumerable{Boxes.Tasks.IBoxesTask{`0}})">
            <summary>
            create wrapper, and add a number of tasks ready for the pipeline
            </summary>
            <param name="tasks">the tasks for the underlying pipeline</param>
        </member>
        <member name="M:Boxes.Integration.Tasks.PipelineExecutorWrapper`1.UpdateTasksAsRequired(System.Collections.Generic.IEnumerable{Boxes.Tasks.IBoxesTask{`0}})">
            <summary>
            update the tasks in the pipeline
            </summary>
            <param name="tasks">sets the tasks for the pipeline</param>
        </member>
        <member name="M:Boxes.Integration.Tasks.PipelineExecutorWrapper`1.UpdateTasksAsRequired">
            <summary>
            update the tasks in the pipeline
            </summary>
        </member>
        <member name="M:Boxes.Integration.Tasks.PipelineExecutorWrapper`1.Execute(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            execute the pipeline
            </summary>
            <param name="item">items to process</param>
            <returns>the collection of items which was passed in</returns>
        </member>
        <member name="T:Boxes.Integration.IDependencyResolver">
            <summary>
            Dependency resolver interface to be used by <see cref="N:Boxes.Integration"/>
            </summary>
        </member>
        <member name="M:Boxes.Integration.IDependencyResolver.Resolve``1">
            <summary>
            resolve an instance
            </summary>
            <typeparam name="T">the service to be resolved</typeparam>
            <returns>an instance of the service</returns>
        </member>
        <member name="M:Boxes.Integration.IDependencyResolver.Resolve(System.Type)">
            <summary>
            resolve an instance
            </summary>
            <param name="type">the service to be resolved</param>
            <returns>an instance of the service</returns>
        </member>
        <member name="M:Boxes.Integration.IDependencyResolver.ResolveAll``1">
            <summary>
            resolve all instance for a service
            </summary>
            <typeparam name="T">the service to be resolved</typeparam>
            <returns>all instances for the service</returns>
        </member>
        <member name="M:Boxes.Integration.IDependencyResolver.ResolveAll(System.Type)">
            <summary>
            resolve all instance for a service
            </summary>
            <param name="type">the service to be resolved</param>
            <returns>all instances for the service</returns>
        </member>
        <member name="M:Boxes.Integration.IDependencyResolver.Release(System.Object)">
            <summary>
            handles the releasing of an instance
            </summary>
            <param name="obj">the object to release</param>
        </member>
        <member name="T:Boxes.Integration.LoaderProxy">
            <summary>
            Loader proxy allows a third party class to see which new packages have
            been loaded
            </summary>
        </member>
        <member name="M:Boxes.Integration.LoaderProxy.#ctor(Boxes.Loading.ILoader)">
            <summary>
            ctor
            </summary>
            <param name="proxied">loader to proxy</param>
        </member>
        <member name="M:Boxes.Integration.LoaderProxy.ClearLoadedPackages">
            <summary>
            clears the load packages, in case you need to do multiple loads
            </summary>
        </member>
        <member name="P:Boxes.Integration.LoaderProxy.Packages">
            <summary>
            any new loaded packages
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.Registrations.Contracts">
            <summary>
            Register with which service contracts
            </summary>
        </member>
        <member name="F:Boxes.Integration.Setup.Registrations.Contracts.AllInterfaces">
            <summary>
            All the interfaces
            </summary>
        </member>
        <member name="F:Boxes.Integration.Setup.Registrations.Contracts.FirstInterface">
            <summary>
            Only the first interface
            </summary>
        </member>
        <member name="F:Boxes.Integration.Setup.Registrations.Contracts.SelfOnly">
            <summary>
            With only the class itself
            </summary>
        </member>
        <member name="F:Boxes.Integration.Setup.Registrations.Contracts.SelfAndAllInterfaces">
            <summary>
            With only the class itself
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.Registrations.Registration">
            <summary>
            This class provides a mechanism to setup the registration of types with the underlying IoC.
            </summary>
        </member>
        <member name="T:Boxes.Integration.Setup.RegistrationMeta">
            <summary>
            stores information about the registration, this will be used to create a boxes task
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.RegistrationMeta.Where">
            <summary>
            filter to apply
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.RegistrationMeta.With">
            <summary>
            what to register it as
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.RegistrationMeta.FactoryMethod">
            <summary>
            use custom ctor
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.RegistrationMeta.LifeStyle">
            <summary>
            the scope of the types which this registration is for
            </summary>
        </member>
        <member name="P:Boxes.Integration.Setup.RegistrationMeta.Configurations">
            <summary>
            a list of configurations to apply
            </summary>
        </member>
        <member name="T:Boxes.Integration.Tasks.TypeScannerTask">
            <summary>
            Generic task which may be helpful
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Boxes.Integration.Extensions.XmlManifest2012ExtensionReader" -->
        <member name="T:Boxes.Integration.Process.Node`1">
            <summary>
            These nodes are used to implement a topological sort
            </summary>
            <typeparam name="T">the item associated with the node</typeparam>
            <remarks>
            based on http://www.patrickdewane.com/2009/03/topological-sort.html
            </remarks>
        </member>
        <member name="P:Boxes.Integration.Process.Node`1.Element">
            <summary>
            The instance this node represents
            </summary>
        </member>
        <member name="P:Boxes.Integration.Process.Node`1.Visited">
            <summary>
            Indicates if the node has been visited/processed
            </summary>
        </member>
        <member name="P:Boxes.Integration.Process.Node`1.Dependencies">
            <summary>
            dependencies of this node
            </summary>
        </member>
        <member name="T:Boxes.Integration.Trust.Filters.FuncContractFilter`1">
            <summary>
            apply the trust of a type given its package context
            </summary>
            <typeparam name="TContract"></typeparam>
        </member>
        <member name="T:Boxes.Integration.Trust.Filters.ContractFilter`1">
            <summary>
            filter a contract and include its package as context, inherit this to provide the IsTrustedContext method
            </summary>
            <typeparam name="TContract">contract</typeparam>
        </member>
        <member name="T:Boxes.Integration.Trust.Filters.TrustFilterBase`1">
            <summary>
            A base trust filter, this adds a basic handle to match the <see cref="T:Boxes.Integration.Trust.Contexts.TrustContext"/>
            </summary>
            <typeparam name="TContext">the <see cref="T:Boxes.Integration.Trust.Contexts.TrustContext"/> this filter will be filter against</typeparam>
        </member>
        <member name="T:Boxes.Integration.Trust.Filters.ITrustFilter">
            <summary>
            A trust filter will see if the context is legit and there is no bad intention happening
            </summary>
        </member>
        <member name="M:Boxes.Integration.Trust.Filters.ITrustFilter.CanHandle(Boxes.Integration.Trust.Contexts.TrustContext)">
            <summary>
            to see if this filter can be applied to the current trust context
            </summary>
            <param name="trustContext">the trust context</param>
            <returns></returns>
        </member>
        <member name="M:Boxes.Integration.Trust.Filters.ITrustFilter.IsTrusted(Boxes.Integration.Trust.Contexts.TrustContext)">
            <summary>
            returns if the context can be trusted
            </summary>
            <param name="trustContext">the trust context</param>
            <returns>true if the context can be trusted</returns>
        </member>
        <member name="P:Boxes.Integration.Trust.Filters.ITrustFilter.HandlesTrustContextType">
            <summary>
            returns the main trust context this filter supports (this is to try and make the process a little faster)
            </summary>
        </member>
        <member name="T:Boxes.Integration.Trust.ITrustManager">
            <summary>
            a trust manager is responsible for validating components to see if they are to be trusted
            some things which the application may be interested in is if a dll has been tampered with
            or if a class type is being exposed from a known dll or a dll which has a certain public key
            </summary>
            <remarks>
            This works on a optimistic way, it looks for a black listing, not a white one.
            </remarks>
        </member>
        <member name="M:Boxes.Integration.Trust.ITrustManager.IsTrusted(Boxes.Integration.Trust.Contexts.TrustContext)">
            <summary>
            this will detail if a class/dll etc is trusted
            </summary>
            <param name="context">the current context to investigate</param>
            <returns>return true if the context can be trusted</returns>
        </member>
        <member name="M:Boxes.Integration.Trust.ITrustManager.AddTrust(Boxes.Integration.Trust.Filters.ITrustFilter)">
            <summary>
            add a trust filter for the manager to use
            </summary>
            <param name="trust">the filer to be applied</param>
        </member>
        <member name="T:Boxes.Integration.Trust.Contexts.BoxesExtensions.TypeFromPackageTrustContext">
            <summary>
            check to see if a type from a package is ok (Boxes Extension)
            </summary>
        </member>
        <member name="P:Boxes.Integration.Trust.Contexts.BoxesExtensions.TypeFromPackageTrustContext.Contract">
            <summary>
            the contract to be added
            </summary>
        </member>
        <member name="P:Boxes.Integration.Trust.Contexts.BoxesExtensions.TypeFromPackageTrustContext.Service">
            <summary>
            the service which will fulfil the contract
            </summary>
        </member>
        <member name="P:Boxes.Integration.Trust.Contexts.BoxesExtensions.TypeFromPackageTrustContext.Package">
            <summary>
            the package where the service was located
            </summary>
        </member>
        <member name="T:Boxes.Integration.Trust.TrustManager">
            <summary>
            Default trust manager
            </summary>
            <remarks>
            this class is sealed, to try and provide some security (ie proxy-ing it)
            
            Also this works on a optimistic way, it looks for a black listing, not a white one.
            
            you may also note the <see cref="T:Boxes.Integration.Extensions.IBoxesExtensionWithSetup"/> interface, this is to allow people configure
            extra filters in modules, to ensure no once replace this with another hacked instance, just add a filter to prevent it.
            </remarks>
        </member>
    </members>
</doc>
